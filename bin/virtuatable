#!/usr/bin/env ruby
require 'thor'
require 'date'
require 'faraday'
require 'json'
require 'octokit'

require File.join(__dir__, 'lib', 'files', 'dockerfile.rb')
require File.join(__dir__, 'lib', 'version.rb')

class String
  def apply!(value, field)
    self.gsub!("{{#{field}}}", value)
  end
  def apply_all!(options)
    options.keys.each do |field|
      self.apply!(options[field], field)
    end
  end
end

class Command < Thor

  desc 'kube', 'Gets, applies or deletes the Kubernetes configuration for a service'
  method_option :port, default: '8080'
  method_option :replicas, default: '3'
  def kube(action, service)
    case action
    when 'display'
      puts get_config(service, options)
    when 'create'
      execute_kubectl_command('apply', service, options)
    when 'delete'
      execute_kubectl_command('delete', service, options)
    end
  end

  desc 'docker', 'Gets informations about the dockerfile for a project'
  method_option :port, default: '8080'
  method_option :bundler, default: '2.1.4'
  method_option :ruby, default: '2.6.5'
  def docker(action, service)
    dockerfile = Virtuatable::Files::Dockerfile.new(service, options)
    case action
    when 'latest'
      puts latest_docker_image(service)
    when 'display'
      puts dockerfile.content
    when 'next'
      puts increase_version(service)
    when 'create'
      v = increase_version(service)
      system "docker build -t virtuatable/#{service}:#{v} -f #{dockerfile.store} ."
      system "docker push virtuatable/#{service}:#{v}"
    end
  end

  desc 'github', 'All commands github relative'
  def github(action, service)
    case action
    when 'last'
      puts last_commit
    when 'increment'
      puts increment(service)
    when 'release'
      puts last_release(service)
    when 'request'
      if last_merged_pr.nil?
        puts "Can't find a PR related to #{last_commit}"
      else
        puts "Found a PR related to #{last_commit}"
      end
    end
  end

  def self.exit_on_failure?
    true
  end

  private

  def increase_version(service)
    r = latest_docker_image(service)
    i = increment(service)
    Virtuatable::Version.new(r).next(type: i).to_s
  end

  def client
    if @client.nil?
      @client = Octokit::Client.new(access_token: ENV['GITHUB_TOKEN'])
    end
    @client
  end

  def last_commit
    `git rev-parse HEAD`.strip
  end

  def last_release(service)
    begin
      client.releases("virtuatable/#{service}")[0][:tag_name]
    rescue
      '0.0.0'
    end
  end

  def increment(service)
    return 'patch' if last_merged_pr.nil?
    tags = last_merged_pr[:labels].map { |l| l[:name] }
    return 'major' if tags.include? 'major'
    return 'minor' if tags.include? 'minor'
    'patch'
  end

  def last_merged_pr
    requests = client.pull_requests('virtuatable/accounts', {state: 'all'})
    requests.each do |request|
      if request[:merge_commit_sha] == last_commit
        return request
      end
    end
    return nil
  end

  def latest_docker_image(service)
    begin
      url = "https://registry.hub.docker.com/v2/repositories/virtuatable/#{service}/tags"
      body = JSON.parse(Faraday.get(url).body)
      body['results'][0]['name']
    rescue
      '0.0.0'
    end
  end

  def parse_content(filename, service, version, options)
    filepath = File.join(__dir__, 'utils', filename)
    content = File.read(filepath)
    content.apply!(service, 'service')
    content.apply!(version, 'version')
    content.apply_all!(options)
    content
  end

  def execute_kubectl_command(command, service, options)
    path = "/tmp/#{service}.yml"
    file = File.open(path, 'w') do |f|
      f.write(get_config(service, options))
    end
    system "cat /tmp/#{service}.yml | kubectl #{command} -f -"
    File.delete(path)
  end

  def get_config(service, options)
    parsed = %w(deployment ingress service).map do |filename|
      parse_content("#{filename}.yml", service, latest_docker_image(service), options)
    end
    parsed.join("\n---\n")
  end
end

Command.start